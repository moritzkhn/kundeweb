{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, Directive, EventEmitter, Optional, Inject, Input, Output, NgModule } from '@angular/core';\nimport { Subject, Observable, ReplaySubject, merge, combineLatest, fromEvent } from 'rxjs';\nimport { filter, mergeMap, startWith, map, share, takeUntil, take, takeLast, count, pairwise, distinctUntilChanged } from 'rxjs/operators';\nimport { DOCUMENT } from '@angular/common';\nimport autoScroll from '@mattlewis92/dom-autoscroller';\n\nfunction addClass(renderer, element, classToAdd) {\n  if (classToAdd) {\n    classToAdd.split(' ').forEach(className => renderer.addClass(element.nativeElement, className));\n  }\n}\n\nfunction removeClass(renderer, element, classToRemove) {\n  if (classToRemove) {\n    classToRemove.split(' ').forEach(className => renderer.removeClass(element.nativeElement, className));\n  }\n}\n\nclass DraggableHelper {\n  constructor() {\n    this.currentDrag = new Subject();\n  }\n\n}\n\nDraggableHelper.ɵfac = function DraggableHelper_Factory(t) {\n  return new (t || DraggableHelper)();\n};\n\nDraggableHelper.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DraggableHelper,\n  factory: DraggableHelper.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DraggableHelper, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n/**\n * If the window isn't scrollable, then place this on the scrollable container that draggable elements are inside. e.g.\n * ```html\n  <div style=\"overflow: scroll\" mwlDraggableScrollContainer>\n    <div mwlDraggable>Drag me!</div>\n  </div>\n  ```\n */\n\n\nclass DraggableScrollContainerDirective {\n  /**\n   * @hidden\n   */\n  constructor(elementRef) {\n    this.elementRef = elementRef;\n  }\n\n}\n\nDraggableScrollContainerDirective.ɵfac = function DraggableScrollContainerDirective_Factory(t) {\n  return new (t || DraggableScrollContainerDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n};\n\nDraggableScrollContainerDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: DraggableScrollContainerDirective,\n  selectors: [[\"\", \"mwlDraggableScrollContainer\", \"\"]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DraggableScrollContainerDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlDraggableScrollContainer]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }];\n  }, null);\n})();\n\nclass DraggableDirective {\n  /**\n   * @hidden\n   */\n  constructor(element, renderer, draggableHelper, zone, vcr, scrollContainer, document) {\n    this.element = element;\n    this.renderer = renderer;\n    this.draggableHelper = draggableHelper;\n    this.zone = zone;\n    this.vcr = vcr;\n    this.scrollContainer = scrollContainer;\n    this.document = document;\n    /**\n     * The axis along which the element is draggable\n     */\n\n    this.dragAxis = {\n      x: true,\n      y: true\n    };\n    /**\n     * Snap all drags to an x / y grid\n     */\n\n    this.dragSnapGrid = {};\n    /**\n     * Show a ghost element that shows the drag when dragging\n     */\n\n    this.ghostDragEnabled = true;\n    /**\n     * Show the original element when ghostDragEnabled is true\n     */\n\n    this.showOriginalElementWhileDragging = false;\n    /**\n     * The cursor to use when hovering over a draggable element\n     */\n\n    this.dragCursor = '';\n    /*\n     * Options used to control the behaviour of auto scrolling: https://www.npmjs.com/package/dom-autoscroller\n     */\n\n    this.autoScroll = {\n      margin: 20\n    };\n    /**\n     * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it\n     */\n\n    this.dragPointerDown = new EventEmitter();\n    /**\n     * Called when the element has started to be dragged.\n     * Only called after at least one mouse or touch move event.\n     * If you call $event.cancelDrag$.emit() it will cancel the current drag\n     */\n\n    this.dragStart = new EventEmitter();\n    /**\n     * Called after the ghost element has been created\n     */\n\n    this.ghostElementCreated = new EventEmitter();\n    /**\n     * Called when the element is being dragged\n     */\n\n    this.dragging = new EventEmitter();\n    /**\n     * Called after the element is dragged\n     */\n\n    this.dragEnd = new EventEmitter();\n    /**\n     * @hidden\n     */\n\n    this.pointerDown$ = new Subject();\n    /**\n     * @hidden\n     */\n\n    this.pointerMove$ = new Subject();\n    /**\n     * @hidden\n     */\n\n    this.pointerUp$ = new Subject();\n    this.eventListenerSubscriptions = {};\n    this.destroy$ = new Subject();\n    this.timeLongPress = {\n      timerBegin: 0,\n      timerEnd: 0\n    };\n  }\n\n  ngOnInit() {\n    this.checkEventListeners();\n    const pointerDragged$ = this.pointerDown$.pipe(filter(() => this.canDrag()), mergeMap(pointerDownEvent => {\n      // fix for https://github.com/mattlewis92/angular-draggable-droppable/issues/61\n      // stop mouse events propagating up the chain\n      if (pointerDownEvent.event.stopPropagation && !this.scrollContainer) {\n        pointerDownEvent.event.stopPropagation();\n      } // hack to prevent text getting selected in safari while dragging\n\n\n      const globalDragStyle = this.renderer.createElement('style');\n      this.renderer.setAttribute(globalDragStyle, 'type', 'text/css');\n      this.renderer.appendChild(globalDragStyle, this.renderer.createText(`\n          body * {\n           -moz-user-select: none;\n           -ms-user-select: none;\n           -webkit-user-select: none;\n           user-select: none;\n          }\n        `));\n      requestAnimationFrame(() => {\n        this.document.head.appendChild(globalDragStyle);\n      });\n      const startScrollPosition = this.getScrollPosition();\n      const scrollContainerScroll$ = new Observable(observer => {\n        const scrollContainer = this.scrollContainer ? this.scrollContainer.elementRef.nativeElement : 'window';\n        return this.renderer.listen(scrollContainer, 'scroll', e => observer.next(e));\n      }).pipe(startWith(startScrollPosition), map(() => this.getScrollPosition()));\n      const currentDrag$ = new Subject();\n      const cancelDrag$ = new ReplaySubject();\n\n      if (this.dragPointerDown.observers.length > 0) {\n        this.zone.run(() => {\n          this.dragPointerDown.next({\n            x: 0,\n            y: 0\n          });\n        });\n      }\n\n      const dragComplete$ = merge(this.pointerUp$, this.pointerDown$, cancelDrag$, this.destroy$).pipe(share());\n      const pointerMove = combineLatest([this.pointerMove$, scrollContainerScroll$]).pipe(map(([pointerMoveEvent, scroll]) => {\n        return {\n          currentDrag$,\n          transformX: pointerMoveEvent.clientX - pointerDownEvent.clientX,\n          transformY: pointerMoveEvent.clientY - pointerDownEvent.clientY,\n          clientX: pointerMoveEvent.clientX,\n          clientY: pointerMoveEvent.clientY,\n          scrollLeft: scroll.left,\n          scrollTop: scroll.top,\n          target: pointerMoveEvent.event.target\n        };\n      }), map(moveData => {\n        if (this.dragSnapGrid.x) {\n          moveData.transformX = Math.round(moveData.transformX / this.dragSnapGrid.x) * this.dragSnapGrid.x;\n        }\n\n        if (this.dragSnapGrid.y) {\n          moveData.transformY = Math.round(moveData.transformY / this.dragSnapGrid.y) * this.dragSnapGrid.y;\n        }\n\n        return moveData;\n      }), map(moveData => {\n        if (!this.dragAxis.x) {\n          moveData.transformX = 0;\n        }\n\n        if (!this.dragAxis.y) {\n          moveData.transformY = 0;\n        }\n\n        return moveData;\n      }), map(moveData => {\n        const scrollX = moveData.scrollLeft - startScrollPosition.left;\n        const scrollY = moveData.scrollTop - startScrollPosition.top;\n        return Object.assign(Object.assign({}, moveData), {\n          x: moveData.transformX + scrollX,\n          y: moveData.transformY + scrollY\n        });\n      }), filter(({\n        x,\n        y,\n        transformX,\n        transformY\n      }) => !this.validateDrag || this.validateDrag({\n        x,\n        y,\n        transform: {\n          x: transformX,\n          y: transformY\n        }\n      })), takeUntil(dragComplete$), share());\n      const dragStarted$ = pointerMove.pipe(take(1), share());\n      const dragEnded$ = pointerMove.pipe(takeLast(1), share());\n      dragStarted$.subscribe(({\n        clientX,\n        clientY,\n        x,\n        y\n      }) => {\n        if (this.dragStart.observers.length > 0) {\n          this.zone.run(() => {\n            this.dragStart.next({\n              cancelDrag$\n            });\n          });\n        }\n\n        this.scroller = autoScroll([this.scrollContainer ? this.scrollContainer.elementRef.nativeElement : this.document.defaultView], Object.assign(Object.assign({}, this.autoScroll), {\n          autoScroll() {\n            return true;\n          }\n\n        }));\n        addClass(this.renderer, this.element, this.dragActiveClass);\n\n        if (this.ghostDragEnabled) {\n          const rect = this.element.nativeElement.getBoundingClientRect();\n          const clone = this.element.nativeElement.cloneNode(true);\n\n          if (!this.showOriginalElementWhileDragging) {\n            this.renderer.setStyle(this.element.nativeElement, 'visibility', 'hidden');\n          }\n\n          if (this.ghostElementAppendTo) {\n            this.ghostElementAppendTo.appendChild(clone);\n          } else {\n            this.element.nativeElement.parentNode.insertBefore(clone, this.element.nativeElement.nextSibling);\n          }\n\n          this.ghostElement = clone;\n          this.document.body.style.cursor = this.dragCursor;\n          this.setElementStyles(clone, {\n            position: 'fixed',\n            top: `${rect.top}px`,\n            left: `${rect.left}px`,\n            width: `${rect.width}px`,\n            height: `${rect.height}px`,\n            cursor: this.dragCursor,\n            margin: '0',\n            willChange: 'transform',\n            pointerEvents: 'none'\n          });\n\n          if (this.ghostElementTemplate) {\n            const viewRef = this.vcr.createEmbeddedView(this.ghostElementTemplate);\n            clone.innerHTML = '';\n            viewRef.rootNodes.filter(node => node instanceof Node).forEach(node => {\n              clone.appendChild(node);\n            });\n            dragEnded$.subscribe(() => {\n              this.vcr.remove(this.vcr.indexOf(viewRef));\n            });\n          }\n\n          if (this.ghostElementCreated.observers.length > 0) {\n            this.zone.run(() => {\n              this.ghostElementCreated.emit({\n                clientX: clientX - x,\n                clientY: clientY - y,\n                element: clone\n              });\n            });\n          }\n\n          dragEnded$.subscribe(() => {\n            clone.parentElement.removeChild(clone);\n            this.ghostElement = null;\n            this.renderer.setStyle(this.element.nativeElement, 'visibility', '');\n          });\n        }\n\n        this.draggableHelper.currentDrag.next(currentDrag$);\n      });\n      dragEnded$.pipe(mergeMap(dragEndData => {\n        const dragEndData$ = cancelDrag$.pipe(count(), take(1), map(calledCount => Object.assign(Object.assign({}, dragEndData), {\n          dragCancelled: calledCount > 0\n        })));\n        cancelDrag$.complete();\n        return dragEndData$;\n      })).subscribe(({\n        x,\n        y,\n        dragCancelled\n      }) => {\n        this.scroller.destroy();\n\n        if (this.dragEnd.observers.length > 0) {\n          this.zone.run(() => {\n            this.dragEnd.next({\n              x,\n              y,\n              dragCancelled\n            });\n          });\n        }\n\n        removeClass(this.renderer, this.element, this.dragActiveClass);\n        currentDrag$.complete();\n      });\n      merge(dragComplete$, dragEnded$).pipe(take(1)).subscribe(() => {\n        requestAnimationFrame(() => {\n          this.document.head.removeChild(globalDragStyle);\n        });\n      });\n      return pointerMove;\n    }), share());\n    merge(pointerDragged$.pipe(take(1), map(value => [, value])), pointerDragged$.pipe(pairwise())).pipe(filter(([previous, next]) => {\n      if (!previous) {\n        return true;\n      }\n\n      return previous.x !== next.x || previous.y !== next.y;\n    }), map(([previous, next]) => next)).subscribe(({\n      x,\n      y,\n      currentDrag$,\n      clientX,\n      clientY,\n      transformX,\n      transformY,\n      target\n    }) => {\n      if (this.dragging.observers.length > 0) {\n        this.zone.run(() => {\n          this.dragging.next({\n            x,\n            y\n          });\n        });\n      }\n\n      requestAnimationFrame(() => {\n        if (this.ghostElement) {\n          const transform = `translate3d(${transformX}px, ${transformY}px, 0px)`;\n          this.setElementStyles(this.ghostElement, {\n            transform,\n            '-webkit-transform': transform,\n            '-ms-transform': transform,\n            '-moz-transform': transform,\n            '-o-transform': transform\n          });\n        }\n      });\n      currentDrag$.next({\n        clientX,\n        clientY,\n        dropData: this.dropData,\n        target\n      });\n    });\n  }\n\n  ngOnChanges(changes) {\n    if (changes.dragAxis) {\n      this.checkEventListeners();\n    }\n  }\n\n  ngOnDestroy() {\n    this.unsubscribeEventListeners();\n    this.pointerDown$.complete();\n    this.pointerMove$.complete();\n    this.pointerUp$.complete();\n    this.destroy$.next();\n  }\n\n  checkEventListeners() {\n    const canDrag = this.canDrag();\n    const hasEventListeners = Object.keys(this.eventListenerSubscriptions).length > 0;\n\n    if (canDrag && !hasEventListeners) {\n      this.zone.runOutsideAngular(() => {\n        this.eventListenerSubscriptions.mousedown = this.renderer.listen(this.element.nativeElement, 'mousedown', event => {\n          this.onMouseDown(event);\n        });\n        this.eventListenerSubscriptions.mouseup = this.renderer.listen('document', 'mouseup', event => {\n          this.onMouseUp(event);\n        });\n        this.eventListenerSubscriptions.touchstart = this.renderer.listen(this.element.nativeElement, 'touchstart', event => {\n          this.onTouchStart(event);\n        });\n        this.eventListenerSubscriptions.touchend = this.renderer.listen('document', 'touchend', event => {\n          this.onTouchEnd(event);\n        });\n        this.eventListenerSubscriptions.touchcancel = this.renderer.listen('document', 'touchcancel', event => {\n          this.onTouchEnd(event);\n        });\n        this.eventListenerSubscriptions.mouseenter = this.renderer.listen(this.element.nativeElement, 'mouseenter', () => {\n          this.onMouseEnter();\n        });\n        this.eventListenerSubscriptions.mouseleave = this.renderer.listen(this.element.nativeElement, 'mouseleave', () => {\n          this.onMouseLeave();\n        });\n      });\n    } else if (!canDrag && hasEventListeners) {\n      this.unsubscribeEventListeners();\n    }\n  }\n\n  onMouseDown(event) {\n    if (event.button === 0) {\n      if (!this.eventListenerSubscriptions.mousemove) {\n        this.eventListenerSubscriptions.mousemove = this.renderer.listen('document', 'mousemove', mouseMoveEvent => {\n          this.pointerMove$.next({\n            event: mouseMoveEvent,\n            clientX: mouseMoveEvent.clientX,\n            clientY: mouseMoveEvent.clientY\n          });\n        });\n      }\n\n      this.pointerDown$.next({\n        event,\n        clientX: event.clientX,\n        clientY: event.clientY\n      });\n    }\n  }\n\n  onMouseUp(event) {\n    if (event.button === 0) {\n      if (this.eventListenerSubscriptions.mousemove) {\n        this.eventListenerSubscriptions.mousemove();\n        delete this.eventListenerSubscriptions.mousemove;\n      }\n\n      this.pointerUp$.next({\n        event,\n        clientX: event.clientX,\n        clientY: event.clientY\n      });\n    }\n  }\n\n  onTouchStart(event) {\n    let startScrollPosition;\n    let isDragActivated;\n    let hasContainerScrollbar;\n\n    if (this.touchStartLongPress) {\n      this.timeLongPress.timerBegin = Date.now();\n      isDragActivated = false;\n      hasContainerScrollbar = this.hasScrollbar();\n      startScrollPosition = this.getScrollPosition();\n    }\n\n    if (!this.eventListenerSubscriptions.touchmove) {\n      const contextMenuListener = fromEvent(this.document, 'contextmenu').subscribe(e => {\n        e.preventDefault();\n      });\n      const touchMoveListener = fromEvent(this.document, 'touchmove', {\n        passive: false\n      }).subscribe(touchMoveEvent => {\n        if (this.touchStartLongPress && !isDragActivated && hasContainerScrollbar) {\n          isDragActivated = this.shouldBeginDrag(event, touchMoveEvent, startScrollPosition);\n        }\n\n        if (!this.touchStartLongPress || !hasContainerScrollbar || isDragActivated) {\n          touchMoveEvent.preventDefault();\n          this.pointerMove$.next({\n            event: touchMoveEvent,\n            clientX: touchMoveEvent.targetTouches[0].clientX,\n            clientY: touchMoveEvent.targetTouches[0].clientY\n          });\n        }\n      });\n\n      this.eventListenerSubscriptions.touchmove = () => {\n        contextMenuListener.unsubscribe();\n        touchMoveListener.unsubscribe();\n      };\n    }\n\n    this.pointerDown$.next({\n      event,\n      clientX: event.touches[0].clientX,\n      clientY: event.touches[0].clientY\n    });\n  }\n\n  onTouchEnd(event) {\n    if (this.eventListenerSubscriptions.touchmove) {\n      this.eventListenerSubscriptions.touchmove();\n      delete this.eventListenerSubscriptions.touchmove;\n\n      if (this.touchStartLongPress) {\n        this.enableScroll();\n      }\n    }\n\n    this.pointerUp$.next({\n      event,\n      clientX: event.changedTouches[0].clientX,\n      clientY: event.changedTouches[0].clientY\n    });\n  }\n\n  onMouseEnter() {\n    this.setCursor(this.dragCursor);\n  }\n\n  onMouseLeave() {\n    this.setCursor('');\n  }\n\n  canDrag() {\n    return this.dragAxis.x || this.dragAxis.y;\n  }\n\n  setCursor(value) {\n    if (!this.eventListenerSubscriptions.mousemove) {\n      this.renderer.setStyle(this.element.nativeElement, 'cursor', value);\n    }\n  }\n\n  unsubscribeEventListeners() {\n    Object.keys(this.eventListenerSubscriptions).forEach(type => {\n      this.eventListenerSubscriptions[type]();\n      delete this.eventListenerSubscriptions[type];\n    });\n  }\n\n  setElementStyles(element, styles) {\n    Object.keys(styles).forEach(key => {\n      this.renderer.setStyle(element, key, styles[key]);\n    });\n  }\n\n  getScrollElement() {\n    if (this.scrollContainer) {\n      return this.scrollContainer.elementRef.nativeElement;\n    } else {\n      return this.document.body;\n    }\n  }\n\n  getScrollPosition() {\n    if (this.scrollContainer) {\n      return {\n        top: this.scrollContainer.elementRef.nativeElement.scrollTop,\n        left: this.scrollContainer.elementRef.nativeElement.scrollLeft\n      };\n    } else {\n      return {\n        top: window.pageYOffset || this.document.documentElement.scrollTop,\n        left: window.pageXOffset || this.document.documentElement.scrollLeft\n      };\n    }\n  }\n\n  shouldBeginDrag(event, touchMoveEvent, startScrollPosition) {\n    const moveScrollPosition = this.getScrollPosition();\n    const deltaScroll = {\n      top: Math.abs(moveScrollPosition.top - startScrollPosition.top),\n      left: Math.abs(moveScrollPosition.left - startScrollPosition.left)\n    };\n    const deltaX = Math.abs(touchMoveEvent.targetTouches[0].clientX - event.touches[0].clientX) - deltaScroll.left;\n    const deltaY = Math.abs(touchMoveEvent.targetTouches[0].clientY - event.touches[0].clientY) - deltaScroll.top;\n    const deltaTotal = deltaX + deltaY;\n    const longPressConfig = this.touchStartLongPress;\n\n    if (deltaTotal > longPressConfig.delta || deltaScroll.top > 0 || deltaScroll.left > 0) {\n      this.timeLongPress.timerBegin = Date.now();\n    }\n\n    this.timeLongPress.timerEnd = Date.now();\n    const duration = this.timeLongPress.timerEnd - this.timeLongPress.timerBegin;\n\n    if (duration >= longPressConfig.delay) {\n      this.disableScroll();\n      return true;\n    }\n\n    return false;\n  }\n\n  enableScroll() {\n    if (this.scrollContainer) {\n      this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', '');\n    }\n\n    this.renderer.setStyle(this.document.body, 'overflow', '');\n  }\n\n  disableScroll() {\n    /* istanbul ignore next */\n    if (this.scrollContainer) {\n      this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', 'hidden');\n    }\n\n    this.renderer.setStyle(this.document.body, 'overflow', 'hidden');\n  }\n\n  hasScrollbar() {\n    const scrollContainer = this.getScrollElement();\n    const containerHasHorizontalScroll = scrollContainer.scrollWidth > scrollContainer.clientWidth;\n    const containerHasVerticalScroll = scrollContainer.scrollHeight > scrollContainer.clientHeight;\n    return containerHasHorizontalScroll || containerHasVerticalScroll;\n  }\n\n}\n\nDraggableDirective.ɵfac = function DraggableDirective_Factory(t) {\n  return new (t || DraggableDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DraggableHelper), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(DraggableScrollContainerDirective, 8), i0.ɵɵdirectiveInject(DOCUMENT));\n};\n\nDraggableDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: DraggableDirective,\n  selectors: [[\"\", \"mwlDraggable\", \"\"]],\n  inputs: {\n    dropData: \"dropData\",\n    dragAxis: \"dragAxis\",\n    dragSnapGrid: \"dragSnapGrid\",\n    ghostDragEnabled: \"ghostDragEnabled\",\n    showOriginalElementWhileDragging: \"showOriginalElementWhileDragging\",\n    validateDrag: \"validateDrag\",\n    dragCursor: \"dragCursor\",\n    dragActiveClass: \"dragActiveClass\",\n    ghostElementAppendTo: \"ghostElementAppendTo\",\n    ghostElementTemplate: \"ghostElementTemplate\",\n    touchStartLongPress: \"touchStartLongPress\",\n    autoScroll: \"autoScroll\"\n  },\n  outputs: {\n    dragPointerDown: \"dragPointerDown\",\n    dragStart: \"dragStart\",\n    ghostElementCreated: \"ghostElementCreated\",\n    dragging: \"dragging\",\n    dragEnd: \"dragEnd\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DraggableDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlDraggable]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: i0.Renderer2\n    }, {\n      type: DraggableHelper\n    }, {\n      type: i0.NgZone\n    }, {\n      type: i0.ViewContainerRef\n    }, {\n      type: DraggableScrollContainerDirective,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, {\n    dropData: [{\n      type: Input\n    }],\n    dragAxis: [{\n      type: Input\n    }],\n    dragSnapGrid: [{\n      type: Input\n    }],\n    ghostDragEnabled: [{\n      type: Input\n    }],\n    showOriginalElementWhileDragging: [{\n      type: Input\n    }],\n    validateDrag: [{\n      type: Input\n    }],\n    dragCursor: [{\n      type: Input\n    }],\n    dragActiveClass: [{\n      type: Input\n    }],\n    ghostElementAppendTo: [{\n      type: Input\n    }],\n    ghostElementTemplate: [{\n      type: Input\n    }],\n    touchStartLongPress: [{\n      type: Input\n    }],\n    autoScroll: [{\n      type: Input\n    }],\n    dragPointerDown: [{\n      type: Output\n    }],\n    dragStart: [{\n      type: Output\n    }],\n    ghostElementCreated: [{\n      type: Output\n    }],\n    dragging: [{\n      type: Output\n    }],\n    dragEnd: [{\n      type: Output\n    }]\n  });\n})();\n\nfunction isCoordinateWithinRectangle(clientX, clientY, rect) {\n  return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\n}\n\nclass DroppableDirective {\n  constructor(element, draggableHelper, zone, renderer, scrollContainer) {\n    this.element = element;\n    this.draggableHelper = draggableHelper;\n    this.zone = zone;\n    this.renderer = renderer;\n    this.scrollContainer = scrollContainer;\n    /**\n     * Called when a draggable element starts overlapping the element\n     */\n\n    this.dragEnter = new EventEmitter();\n    /**\n     * Called when a draggable element stops overlapping the element\n     */\n\n    this.dragLeave = new EventEmitter();\n    /**\n     * Called when a draggable element is moved over the element\n     */\n\n    this.dragOver = new EventEmitter();\n    /**\n     * Called when a draggable element is dropped on this element\n     */\n\n    this.drop = new EventEmitter(); // eslint-disable-line  @angular-eslint/no-output-native\n  }\n\n  ngOnInit() {\n    this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe(drag$ => {\n      addClass(this.renderer, this.element, this.dragActiveClass);\n      const droppableElement = {\n        updateCache: true\n      };\n      const deregisterScrollListener = this.renderer.listen(this.scrollContainer ? this.scrollContainer.elementRef.nativeElement : 'window', 'scroll', () => {\n        droppableElement.updateCache = true;\n      });\n      let currentDragEvent;\n      const overlaps$ = drag$.pipe(map(({\n        clientX,\n        clientY,\n        dropData,\n        target\n      }) => {\n        currentDragEvent = {\n          clientX,\n          clientY,\n          dropData,\n          target\n        };\n\n        if (droppableElement.updateCache) {\n          droppableElement.rect = this.element.nativeElement.getBoundingClientRect();\n\n          if (this.scrollContainer) {\n            droppableElement.scrollContainerRect = this.scrollContainer.elementRef.nativeElement.getBoundingClientRect();\n          }\n\n          droppableElement.updateCache = false;\n        }\n\n        const isWithinElement = isCoordinateWithinRectangle(clientX, clientY, droppableElement.rect);\n        const isDropAllowed = !this.validateDrop || this.validateDrop({\n          clientX,\n          clientY,\n          target,\n          dropData\n        });\n\n        if (droppableElement.scrollContainerRect) {\n          return isWithinElement && isDropAllowed && isCoordinateWithinRectangle(clientX, clientY, droppableElement.scrollContainerRect);\n        } else {\n          return isWithinElement && isDropAllowed;\n        }\n      }));\n      const overlapsChanged$ = overlaps$.pipe(distinctUntilChanged());\n      let dragOverActive; // TODO - see if there's a way of doing this via rxjs\n\n      overlapsChanged$.pipe(filter(overlapsNow => overlapsNow)).subscribe(() => {\n        dragOverActive = true;\n        addClass(this.renderer, this.element, this.dragOverClass);\n\n        if (this.dragEnter.observers.length > 0) {\n          this.zone.run(() => {\n            this.dragEnter.next(currentDragEvent);\n          });\n        }\n      });\n      overlaps$.pipe(filter(overlapsNow => overlapsNow)).subscribe(() => {\n        if (this.dragOver.observers.length > 0) {\n          this.zone.run(() => {\n            this.dragOver.next(currentDragEvent);\n          });\n        }\n      });\n      overlapsChanged$.pipe(pairwise(), filter(([didOverlap, overlapsNow]) => didOverlap && !overlapsNow)).subscribe(() => {\n        dragOverActive = false;\n        removeClass(this.renderer, this.element, this.dragOverClass);\n\n        if (this.dragLeave.observers.length > 0) {\n          this.zone.run(() => {\n            this.dragLeave.next(currentDragEvent);\n          });\n        }\n      });\n      drag$.subscribe({\n        complete: () => {\n          deregisterScrollListener();\n          removeClass(this.renderer, this.element, this.dragActiveClass);\n\n          if (dragOverActive) {\n            removeClass(this.renderer, this.element, this.dragOverClass);\n\n            if (this.drop.observers.length > 0) {\n              this.zone.run(() => {\n                this.drop.next(currentDragEvent);\n              });\n            }\n          }\n        }\n      });\n    });\n  }\n\n  ngOnDestroy() {\n    if (this.currentDragSubscription) {\n      this.currentDragSubscription.unsubscribe();\n    }\n  }\n\n}\n\nDroppableDirective.ɵfac = function DroppableDirective_Factory(t) {\n  return new (t || DroppableDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(DraggableHelper), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DraggableScrollContainerDirective, 8));\n};\n\nDroppableDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: DroppableDirective,\n  selectors: [[\"\", \"mwlDroppable\", \"\"]],\n  inputs: {\n    dragOverClass: \"dragOverClass\",\n    dragActiveClass: \"dragActiveClass\",\n    validateDrop: \"validateDrop\"\n  },\n  outputs: {\n    dragEnter: \"dragEnter\",\n    dragLeave: \"dragLeave\",\n    dragOver: \"dragOver\",\n    drop: \"drop\"\n  }\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DroppableDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlDroppable]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: DraggableHelper\n    }, {\n      type: i0.NgZone\n    }, {\n      type: i0.Renderer2\n    }, {\n      type: DraggableScrollContainerDirective,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, {\n    dragOverClass: [{\n      type: Input\n    }],\n    dragActiveClass: [{\n      type: Input\n    }],\n    validateDrop: [{\n      type: Input\n    }],\n    dragEnter: [{\n      type: Output\n    }],\n    dragLeave: [{\n      type: Output\n    }],\n    dragOver: [{\n      type: Output\n    }],\n    drop: [{\n      type: Output\n    }]\n  });\n})();\n\nclass DragAndDropModule {}\n\nDragAndDropModule.ɵfac = function DragAndDropModule_Factory(t) {\n  return new (t || DragAndDropModule)();\n};\n\nDragAndDropModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: DragAndDropModule\n});\nDragAndDropModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DragAndDropModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective],\n      exports: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective]\n    }]\n  }], null, null);\n})();\n/*\n * Public API Surface of angular-draggable-droppable\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { DragAndDropModule, DraggableDirective, DraggableScrollContainerDirective, DroppableDirective };","map":{"version":3,"sources":["C:/Users/Student/workspace/kundeweb/node_modules/angular-calendar/node_modules/angular-draggable-droppable/fesm2015/angular-draggable-droppable.js"],"names":["i0","Injectable","Directive","EventEmitter","Optional","Inject","Input","Output","NgModule","Subject","Observable","ReplaySubject","merge","combineLatest","fromEvent","filter","mergeMap","startWith","map","share","takeUntil","take","takeLast","count","pairwise","distinctUntilChanged","DOCUMENT","autoScroll","addClass","renderer","element","classToAdd","split","forEach","className","nativeElement","removeClass","classToRemove","DraggableHelper","constructor","currentDrag","ɵfac","ɵprov","type","args","providedIn","DraggableScrollContainerDirective","elementRef","ElementRef","ɵdir","selector","DraggableDirective","draggableHelper","zone","vcr","scrollContainer","document","dragAxis","x","y","dragSnapGrid","ghostDragEnabled","showOriginalElementWhileDragging","dragCursor","margin","dragPointerDown","dragStart","ghostElementCreated","dragging","dragEnd","pointerDown$","pointerMove$","pointerUp$","eventListenerSubscriptions","destroy$","timeLongPress","timerBegin","timerEnd","ngOnInit","checkEventListeners","pointerDragged$","pipe","canDrag","pointerDownEvent","event","stopPropagation","globalDragStyle","createElement","setAttribute","appendChild","createText","requestAnimationFrame","head","startScrollPosition","getScrollPosition","scrollContainerScroll$","observer","listen","e","next","currentDrag$","cancelDrag$","observers","length","run","dragComplete$","pointerMove","pointerMoveEvent","scroll","transformX","clientX","transformY","clientY","scrollLeft","left","scrollTop","top","target","moveData","Math","round","scrollX","scrollY","Object","assign","validateDrag","transform","dragStarted$","dragEnded$","subscribe","scroller","defaultView","dragActiveClass","rect","getBoundingClientRect","clone","cloneNode","setStyle","ghostElementAppendTo","parentNode","insertBefore","nextSibling","ghostElement","body","style","cursor","setElementStyles","position","width","height","willChange","pointerEvents","ghostElementTemplate","viewRef","createEmbeddedView","innerHTML","rootNodes","node","Node","remove","indexOf","emit","parentElement","removeChild","dragEndData","dragEndData$","calledCount","dragCancelled","complete","destroy","value","previous","dropData","ngOnChanges","changes","ngOnDestroy","unsubscribeEventListeners","hasEventListeners","keys","runOutsideAngular","mousedown","onMouseDown","mouseup","onMouseUp","touchstart","onTouchStart","touchend","onTouchEnd","touchcancel","mouseenter","onMouseEnter","mouseleave","onMouseLeave","button","mousemove","mouseMoveEvent","isDragActivated","hasContainerScrollbar","touchStartLongPress","Date","now","hasScrollbar","touchmove","contextMenuListener","preventDefault","touchMoveListener","passive","touchMoveEvent","shouldBeginDrag","targetTouches","unsubscribe","touches","enableScroll","changedTouches","setCursor","styles","key","getScrollElement","window","pageYOffset","documentElement","pageXOffset","moveScrollPosition","deltaScroll","abs","deltaX","deltaY","deltaTotal","longPressConfig","delta","duration","delay","disableScroll","containerHasHorizontalScroll","scrollWidth","clientWidth","containerHasVerticalScroll","scrollHeight","clientHeight","Renderer2","NgZone","ViewContainerRef","decorators","undefined","isCoordinateWithinRectangle","right","bottom","DroppableDirective","dragEnter","dragLeave","dragOver","drop","currentDragSubscription","drag$","droppableElement","updateCache","deregisterScrollListener","currentDragEvent","overlaps$","scrollContainerRect","isWithinElement","isDropAllowed","validateDrop","overlapsChanged$","dragOverActive","overlapsNow","dragOverClass","didOverlap","DragAndDropModule","ɵmod","ɵinj","declarations","exports"],"mappings":"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","sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, Directive, EventEmitter, Optional, Inject, Input, Output, NgModule } from '@angular/core';\nimport { Subject, Observable, ReplaySubject, merge, combineLatest, fromEvent } from 'rxjs';\nimport { filter, mergeMap, startWith, map, share, takeUntil, take, takeLast, count, pairwise, distinctUntilChanged } from 'rxjs/operators';\nimport { DOCUMENT } from '@angular/common';\nimport autoScroll from '@mattlewis92/dom-autoscroller';\n\nfunction addClass(renderer, element, classToAdd) {\n    if (classToAdd) {\n        classToAdd\n            .split(' ')\n            .forEach((className) => renderer.addClass(element.nativeElement, className));\n    }\n}\nfunction removeClass(renderer, element, classToRemove) {\n    if (classToRemove) {\n        classToRemove\n            .split(' ')\n            .forEach((className) => renderer.removeClass(element.nativeElement, className));\n    }\n}\n\nclass DraggableHelper {\n    constructor() {\n        this.currentDrag = new Subject();\n    }\n}\nDraggableHelper.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: DraggableHelper, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nDraggableHelper.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: DraggableHelper, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: DraggableHelper, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }] });\n\n/**\n * If the window isn't scrollable, then place this on the scrollable container that draggable elements are inside. e.g.\n * ```html\n  <div style=\"overflow: scroll\" mwlDraggableScrollContainer>\n    <div mwlDraggable>Drag me!</div>\n  </div>\n  ```\n */\nclass DraggableScrollContainerDirective {\n    /**\n     * @hidden\n     */\n    constructor(elementRef) {\n        this.elementRef = elementRef;\n    }\n}\nDraggableScrollContainerDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: DraggableScrollContainerDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });\nDraggableScrollContainerDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"12.2.3\", type: DraggableScrollContainerDirective, selector: \"[mwlDraggableScrollContainer]\", ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: DraggableScrollContainerDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[mwlDraggableScrollContainer]',\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });\n\nclass DraggableDirective {\n    /**\n     * @hidden\n     */\n    constructor(element, renderer, draggableHelper, zone, vcr, scrollContainer, document) {\n        this.element = element;\n        this.renderer = renderer;\n        this.draggableHelper = draggableHelper;\n        this.zone = zone;\n        this.vcr = vcr;\n        this.scrollContainer = scrollContainer;\n        this.document = document;\n        /**\n         * The axis along which the element is draggable\n         */\n        this.dragAxis = { x: true, y: true };\n        /**\n         * Snap all drags to an x / y grid\n         */\n        this.dragSnapGrid = {};\n        /**\n         * Show a ghost element that shows the drag when dragging\n         */\n        this.ghostDragEnabled = true;\n        /**\n         * Show the original element when ghostDragEnabled is true\n         */\n        this.showOriginalElementWhileDragging = false;\n        /**\n         * The cursor to use when hovering over a draggable element\n         */\n        this.dragCursor = '';\n        /*\n         * Options used to control the behaviour of auto scrolling: https://www.npmjs.com/package/dom-autoscroller\n         */\n        this.autoScroll = {\n            margin: 20,\n        };\n        /**\n         * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it\n         */\n        this.dragPointerDown = new EventEmitter();\n        /**\n         * Called when the element has started to be dragged.\n         * Only called after at least one mouse or touch move event.\n         * If you call $event.cancelDrag$.emit() it will cancel the current drag\n         */\n        this.dragStart = new EventEmitter();\n        /**\n         * Called after the ghost element has been created\n         */\n        this.ghostElementCreated = new EventEmitter();\n        /**\n         * Called when the element is being dragged\n         */\n        this.dragging = new EventEmitter();\n        /**\n         * Called after the element is dragged\n         */\n        this.dragEnd = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.pointerDown$ = new Subject();\n        /**\n         * @hidden\n         */\n        this.pointerMove$ = new Subject();\n        /**\n         * @hidden\n         */\n        this.pointerUp$ = new Subject();\n        this.eventListenerSubscriptions = {};\n        this.destroy$ = new Subject();\n        this.timeLongPress = { timerBegin: 0, timerEnd: 0 };\n    }\n    ngOnInit() {\n        this.checkEventListeners();\n        const pointerDragged$ = this.pointerDown$.pipe(filter(() => this.canDrag()), mergeMap((pointerDownEvent) => {\n            // fix for https://github.com/mattlewis92/angular-draggable-droppable/issues/61\n            // stop mouse events propagating up the chain\n            if (pointerDownEvent.event.stopPropagation && !this.scrollContainer) {\n                pointerDownEvent.event.stopPropagation();\n            }\n            // hack to prevent text getting selected in safari while dragging\n            const globalDragStyle = this.renderer.createElement('style');\n            this.renderer.setAttribute(globalDragStyle, 'type', 'text/css');\n            this.renderer.appendChild(globalDragStyle, this.renderer.createText(`\n          body * {\n           -moz-user-select: none;\n           -ms-user-select: none;\n           -webkit-user-select: none;\n           user-select: none;\n          }\n        `));\n            requestAnimationFrame(() => {\n                this.document.head.appendChild(globalDragStyle);\n            });\n            const startScrollPosition = this.getScrollPosition();\n            const scrollContainerScroll$ = new Observable((observer) => {\n                const scrollContainer = this.scrollContainer\n                    ? this.scrollContainer.elementRef.nativeElement\n                    : 'window';\n                return this.renderer.listen(scrollContainer, 'scroll', (e) => observer.next(e));\n            }).pipe(startWith(startScrollPosition), map(() => this.getScrollPosition()));\n            const currentDrag$ = new Subject();\n            const cancelDrag$ = new ReplaySubject();\n            if (this.dragPointerDown.observers.length > 0) {\n                this.zone.run(() => {\n                    this.dragPointerDown.next({ x: 0, y: 0 });\n                });\n            }\n            const dragComplete$ = merge(this.pointerUp$, this.pointerDown$, cancelDrag$, this.destroy$).pipe(share());\n            const pointerMove = combineLatest([\n                this.pointerMove$,\n                scrollContainerScroll$,\n            ]).pipe(map(([pointerMoveEvent, scroll]) => {\n                return {\n                    currentDrag$,\n                    transformX: pointerMoveEvent.clientX - pointerDownEvent.clientX,\n                    transformY: pointerMoveEvent.clientY - pointerDownEvent.clientY,\n                    clientX: pointerMoveEvent.clientX,\n                    clientY: pointerMoveEvent.clientY,\n                    scrollLeft: scroll.left,\n                    scrollTop: scroll.top,\n                    target: pointerMoveEvent.event.target,\n                };\n            }), map((moveData) => {\n                if (this.dragSnapGrid.x) {\n                    moveData.transformX =\n                        Math.round(moveData.transformX / this.dragSnapGrid.x) *\n                            this.dragSnapGrid.x;\n                }\n                if (this.dragSnapGrid.y) {\n                    moveData.transformY =\n                        Math.round(moveData.transformY / this.dragSnapGrid.y) *\n                            this.dragSnapGrid.y;\n                }\n                return moveData;\n            }), map((moveData) => {\n                if (!this.dragAxis.x) {\n                    moveData.transformX = 0;\n                }\n                if (!this.dragAxis.y) {\n                    moveData.transformY = 0;\n                }\n                return moveData;\n            }), map((moveData) => {\n                const scrollX = moveData.scrollLeft - startScrollPosition.left;\n                const scrollY = moveData.scrollTop - startScrollPosition.top;\n                return Object.assign(Object.assign({}, moveData), { x: moveData.transformX + scrollX, y: moveData.transformY + scrollY });\n            }), filter(({ x, y, transformX, transformY }) => !this.validateDrag ||\n                this.validateDrag({\n                    x,\n                    y,\n                    transform: { x: transformX, y: transformY },\n                })), takeUntil(dragComplete$), share());\n            const dragStarted$ = pointerMove.pipe(take(1), share());\n            const dragEnded$ = pointerMove.pipe(takeLast(1), share());\n            dragStarted$.subscribe(({ clientX, clientY, x, y }) => {\n                if (this.dragStart.observers.length > 0) {\n                    this.zone.run(() => {\n                        this.dragStart.next({ cancelDrag$ });\n                    });\n                }\n                this.scroller = autoScroll([\n                    this.scrollContainer\n                        ? this.scrollContainer.elementRef.nativeElement\n                        : this.document.defaultView,\n                ], Object.assign(Object.assign({}, this.autoScroll), { autoScroll() {\n                        return true;\n                    } }));\n                addClass(this.renderer, this.element, this.dragActiveClass);\n                if (this.ghostDragEnabled) {\n                    const rect = this.element.nativeElement.getBoundingClientRect();\n                    const clone = this.element.nativeElement.cloneNode(true);\n                    if (!this.showOriginalElementWhileDragging) {\n                        this.renderer.setStyle(this.element.nativeElement, 'visibility', 'hidden');\n                    }\n                    if (this.ghostElementAppendTo) {\n                        this.ghostElementAppendTo.appendChild(clone);\n                    }\n                    else {\n                        this.element.nativeElement.parentNode.insertBefore(clone, this.element.nativeElement.nextSibling);\n                    }\n                    this.ghostElement = clone;\n                    this.document.body.style.cursor = this.dragCursor;\n                    this.setElementStyles(clone, {\n                        position: 'fixed',\n                        top: `${rect.top}px`,\n                        left: `${rect.left}px`,\n                        width: `${rect.width}px`,\n                        height: `${rect.height}px`,\n                        cursor: this.dragCursor,\n                        margin: '0',\n                        willChange: 'transform',\n                        pointerEvents: 'none',\n                    });\n                    if (this.ghostElementTemplate) {\n                        const viewRef = this.vcr.createEmbeddedView(this.ghostElementTemplate);\n                        clone.innerHTML = '';\n                        viewRef.rootNodes\n                            .filter((node) => node instanceof Node)\n                            .forEach((node) => {\n                            clone.appendChild(node);\n                        });\n                        dragEnded$.subscribe(() => {\n                            this.vcr.remove(this.vcr.indexOf(viewRef));\n                        });\n                    }\n                    if (this.ghostElementCreated.observers.length > 0) {\n                        this.zone.run(() => {\n                            this.ghostElementCreated.emit({\n                                clientX: clientX - x,\n                                clientY: clientY - y,\n                                element: clone,\n                            });\n                        });\n                    }\n                    dragEnded$.subscribe(() => {\n                        clone.parentElement.removeChild(clone);\n                        this.ghostElement = null;\n                        this.renderer.setStyle(this.element.nativeElement, 'visibility', '');\n                    });\n                }\n                this.draggableHelper.currentDrag.next(currentDrag$);\n            });\n            dragEnded$\n                .pipe(mergeMap((dragEndData) => {\n                const dragEndData$ = cancelDrag$.pipe(count(), take(1), map((calledCount) => (Object.assign(Object.assign({}, dragEndData), { dragCancelled: calledCount > 0 }))));\n                cancelDrag$.complete();\n                return dragEndData$;\n            }))\n                .subscribe(({ x, y, dragCancelled }) => {\n                this.scroller.destroy();\n                if (this.dragEnd.observers.length > 0) {\n                    this.zone.run(() => {\n                        this.dragEnd.next({ x, y, dragCancelled });\n                    });\n                }\n                removeClass(this.renderer, this.element, this.dragActiveClass);\n                currentDrag$.complete();\n            });\n            merge(dragComplete$, dragEnded$)\n                .pipe(take(1))\n                .subscribe(() => {\n                requestAnimationFrame(() => {\n                    this.document.head.removeChild(globalDragStyle);\n                });\n            });\n            return pointerMove;\n        }), share());\n        merge(pointerDragged$.pipe(take(1), map((value) => [, value])), pointerDragged$.pipe(pairwise()))\n            .pipe(filter(([previous, next]) => {\n            if (!previous) {\n                return true;\n            }\n            return previous.x !== next.x || previous.y !== next.y;\n        }), map(([previous, next]) => next))\n            .subscribe(({ x, y, currentDrag$, clientX, clientY, transformX, transformY, target, }) => {\n            if (this.dragging.observers.length > 0) {\n                this.zone.run(() => {\n                    this.dragging.next({ x, y });\n                });\n            }\n            requestAnimationFrame(() => {\n                if (this.ghostElement) {\n                    const transform = `translate3d(${transformX}px, ${transformY}px, 0px)`;\n                    this.setElementStyles(this.ghostElement, {\n                        transform,\n                        '-webkit-transform': transform,\n                        '-ms-transform': transform,\n                        '-moz-transform': transform,\n                        '-o-transform': transform,\n                    });\n                }\n            });\n            currentDrag$.next({\n                clientX,\n                clientY,\n                dropData: this.dropData,\n                target,\n            });\n        });\n    }\n    ngOnChanges(changes) {\n        if (changes.dragAxis) {\n            this.checkEventListeners();\n        }\n    }\n    ngOnDestroy() {\n        this.unsubscribeEventListeners();\n        this.pointerDown$.complete();\n        this.pointerMove$.complete();\n        this.pointerUp$.complete();\n        this.destroy$.next();\n    }\n    checkEventListeners() {\n        const canDrag = this.canDrag();\n        const hasEventListeners = Object.keys(this.eventListenerSubscriptions).length > 0;\n        if (canDrag && !hasEventListeners) {\n            this.zone.runOutsideAngular(() => {\n                this.eventListenerSubscriptions.mousedown = this.renderer.listen(this.element.nativeElement, 'mousedown', (event) => {\n                    this.onMouseDown(event);\n                });\n                this.eventListenerSubscriptions.mouseup = this.renderer.listen('document', 'mouseup', (event) => {\n                    this.onMouseUp(event);\n                });\n                this.eventListenerSubscriptions.touchstart = this.renderer.listen(this.element.nativeElement, 'touchstart', (event) => {\n                    this.onTouchStart(event);\n                });\n                this.eventListenerSubscriptions.touchend = this.renderer.listen('document', 'touchend', (event) => {\n                    this.onTouchEnd(event);\n                });\n                this.eventListenerSubscriptions.touchcancel = this.renderer.listen('document', 'touchcancel', (event) => {\n                    this.onTouchEnd(event);\n                });\n                this.eventListenerSubscriptions.mouseenter = this.renderer.listen(this.element.nativeElement, 'mouseenter', () => {\n                    this.onMouseEnter();\n                });\n                this.eventListenerSubscriptions.mouseleave = this.renderer.listen(this.element.nativeElement, 'mouseleave', () => {\n                    this.onMouseLeave();\n                });\n            });\n        }\n        else if (!canDrag && hasEventListeners) {\n            this.unsubscribeEventListeners();\n        }\n    }\n    onMouseDown(event) {\n        if (event.button === 0) {\n            if (!this.eventListenerSubscriptions.mousemove) {\n                this.eventListenerSubscriptions.mousemove = this.renderer.listen('document', 'mousemove', (mouseMoveEvent) => {\n                    this.pointerMove$.next({\n                        event: mouseMoveEvent,\n                        clientX: mouseMoveEvent.clientX,\n                        clientY: mouseMoveEvent.clientY,\n                    });\n                });\n            }\n            this.pointerDown$.next({\n                event,\n                clientX: event.clientX,\n                clientY: event.clientY,\n            });\n        }\n    }\n    onMouseUp(event) {\n        if (event.button === 0) {\n            if (this.eventListenerSubscriptions.mousemove) {\n                this.eventListenerSubscriptions.mousemove();\n                delete this.eventListenerSubscriptions.mousemove;\n            }\n            this.pointerUp$.next({\n                event,\n                clientX: event.clientX,\n                clientY: event.clientY,\n            });\n        }\n    }\n    onTouchStart(event) {\n        let startScrollPosition;\n        let isDragActivated;\n        let hasContainerScrollbar;\n        if (this.touchStartLongPress) {\n            this.timeLongPress.timerBegin = Date.now();\n            isDragActivated = false;\n            hasContainerScrollbar = this.hasScrollbar();\n            startScrollPosition = this.getScrollPosition();\n        }\n        if (!this.eventListenerSubscriptions.touchmove) {\n            const contextMenuListener = fromEvent(this.document, 'contextmenu').subscribe((e) => {\n                e.preventDefault();\n            });\n            const touchMoveListener = fromEvent(this.document, 'touchmove', {\n                passive: false,\n            }).subscribe((touchMoveEvent) => {\n                if (this.touchStartLongPress &&\n                    !isDragActivated &&\n                    hasContainerScrollbar) {\n                    isDragActivated = this.shouldBeginDrag(event, touchMoveEvent, startScrollPosition);\n                }\n                if (!this.touchStartLongPress ||\n                    !hasContainerScrollbar ||\n                    isDragActivated) {\n                    touchMoveEvent.preventDefault();\n                    this.pointerMove$.next({\n                        event: touchMoveEvent,\n                        clientX: touchMoveEvent.targetTouches[0].clientX,\n                        clientY: touchMoveEvent.targetTouches[0].clientY,\n                    });\n                }\n            });\n            this.eventListenerSubscriptions.touchmove = () => {\n                contextMenuListener.unsubscribe();\n                touchMoveListener.unsubscribe();\n            };\n        }\n        this.pointerDown$.next({\n            event,\n            clientX: event.touches[0].clientX,\n            clientY: event.touches[0].clientY,\n        });\n    }\n    onTouchEnd(event) {\n        if (this.eventListenerSubscriptions.touchmove) {\n            this.eventListenerSubscriptions.touchmove();\n            delete this.eventListenerSubscriptions.touchmove;\n            if (this.touchStartLongPress) {\n                this.enableScroll();\n            }\n        }\n        this.pointerUp$.next({\n            event,\n            clientX: event.changedTouches[0].clientX,\n            clientY: event.changedTouches[0].clientY,\n        });\n    }\n    onMouseEnter() {\n        this.setCursor(this.dragCursor);\n    }\n    onMouseLeave() {\n        this.setCursor('');\n    }\n    canDrag() {\n        return this.dragAxis.x || this.dragAxis.y;\n    }\n    setCursor(value) {\n        if (!this.eventListenerSubscriptions.mousemove) {\n            this.renderer.setStyle(this.element.nativeElement, 'cursor', value);\n        }\n    }\n    unsubscribeEventListeners() {\n        Object.keys(this.eventListenerSubscriptions).forEach((type) => {\n            this.eventListenerSubscriptions[type]();\n            delete this.eventListenerSubscriptions[type];\n        });\n    }\n    setElementStyles(element, styles) {\n        Object.keys(styles).forEach((key) => {\n            this.renderer.setStyle(element, key, styles[key]);\n        });\n    }\n    getScrollElement() {\n        if (this.scrollContainer) {\n            return this.scrollContainer.elementRef.nativeElement;\n        }\n        else {\n            return this.document.body;\n        }\n    }\n    getScrollPosition() {\n        if (this.scrollContainer) {\n            return {\n                top: this.scrollContainer.elementRef.nativeElement.scrollTop,\n                left: this.scrollContainer.elementRef.nativeElement.scrollLeft,\n            };\n        }\n        else {\n            return {\n                top: window.pageYOffset || this.document.documentElement.scrollTop,\n                left: window.pageXOffset || this.document.documentElement.scrollLeft,\n            };\n        }\n    }\n    shouldBeginDrag(event, touchMoveEvent, startScrollPosition) {\n        const moveScrollPosition = this.getScrollPosition();\n        const deltaScroll = {\n            top: Math.abs(moveScrollPosition.top - startScrollPosition.top),\n            left: Math.abs(moveScrollPosition.left - startScrollPosition.left),\n        };\n        const deltaX = Math.abs(touchMoveEvent.targetTouches[0].clientX - event.touches[0].clientX) - deltaScroll.left;\n        const deltaY = Math.abs(touchMoveEvent.targetTouches[0].clientY - event.touches[0].clientY) - deltaScroll.top;\n        const deltaTotal = deltaX + deltaY;\n        const longPressConfig = this.touchStartLongPress;\n        if (deltaTotal > longPressConfig.delta ||\n            deltaScroll.top > 0 ||\n            deltaScroll.left > 0) {\n            this.timeLongPress.timerBegin = Date.now();\n        }\n        this.timeLongPress.timerEnd = Date.now();\n        const duration = this.timeLongPress.timerEnd - this.timeLongPress.timerBegin;\n        if (duration >= longPressConfig.delay) {\n            this.disableScroll();\n            return true;\n        }\n        return false;\n    }\n    enableScroll() {\n        if (this.scrollContainer) {\n            this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', '');\n        }\n        this.renderer.setStyle(this.document.body, 'overflow', '');\n    }\n    disableScroll() {\n        /* istanbul ignore next */\n        if (this.scrollContainer) {\n            this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', 'hidden');\n        }\n        this.renderer.setStyle(this.document.body, 'overflow', 'hidden');\n    }\n    hasScrollbar() {\n        const scrollContainer = this.getScrollElement();\n        const containerHasHorizontalScroll = scrollContainer.scrollWidth > scrollContainer.clientWidth;\n        const containerHasVerticalScroll = scrollContainer.scrollHeight > scrollContainer.clientHeight;\n        return containerHasHorizontalScroll || containerHasVerticalScroll;\n    }\n}\nDraggableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: DraggableDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: DraggableHelper }, { token: i0.NgZone }, { token: i0.ViewContainerRef }, { token: DraggableScrollContainerDirective, optional: true }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Directive });\nDraggableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"12.2.3\", type: DraggableDirective, selector: \"[mwlDraggable]\", inputs: { dropData: \"dropData\", dragAxis: \"dragAxis\", dragSnapGrid: \"dragSnapGrid\", ghostDragEnabled: \"ghostDragEnabled\", showOriginalElementWhileDragging: \"showOriginalElementWhileDragging\", validateDrag: \"validateDrag\", dragCursor: \"dragCursor\", dragActiveClass: \"dragActiveClass\", ghostElementAppendTo: \"ghostElementAppendTo\", ghostElementTemplate: \"ghostElementTemplate\", touchStartLongPress: \"touchStartLongPress\", autoScroll: \"autoScroll\" }, outputs: { dragPointerDown: \"dragPointerDown\", dragStart: \"dragStart\", ghostElementCreated: \"ghostElementCreated\", dragging: \"dragging\", dragEnd: \"dragEnd\" }, usesOnChanges: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: DraggableDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[mwlDraggable]',\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: DraggableHelper }, { type: i0.NgZone }, { type: i0.ViewContainerRef }, { type: DraggableScrollContainerDirective, decorators: [{\n                    type: Optional\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }]; }, propDecorators: { dropData: [{\n                type: Input\n            }], dragAxis: [{\n                type: Input\n            }], dragSnapGrid: [{\n                type: Input\n            }], ghostDragEnabled: [{\n                type: Input\n            }], showOriginalElementWhileDragging: [{\n                type: Input\n            }], validateDrag: [{\n                type: Input\n            }], dragCursor: [{\n                type: Input\n            }], dragActiveClass: [{\n                type: Input\n            }], ghostElementAppendTo: [{\n                type: Input\n            }], ghostElementTemplate: [{\n                type: Input\n            }], touchStartLongPress: [{\n                type: Input\n            }], autoScroll: [{\n                type: Input\n            }], dragPointerDown: [{\n                type: Output\n            }], dragStart: [{\n                type: Output\n            }], ghostElementCreated: [{\n                type: Output\n            }], dragging: [{\n                type: Output\n            }], dragEnd: [{\n                type: Output\n            }] } });\n\nfunction isCoordinateWithinRectangle(clientX, clientY, rect) {\n    return (clientX >= rect.left &&\n        clientX <= rect.right &&\n        clientY >= rect.top &&\n        clientY <= rect.bottom);\n}\nclass DroppableDirective {\n    constructor(element, draggableHelper, zone, renderer, scrollContainer) {\n        this.element = element;\n        this.draggableHelper = draggableHelper;\n        this.zone = zone;\n        this.renderer = renderer;\n        this.scrollContainer = scrollContainer;\n        /**\n         * Called when a draggable element starts overlapping the element\n         */\n        this.dragEnter = new EventEmitter();\n        /**\n         * Called when a draggable element stops overlapping the element\n         */\n        this.dragLeave = new EventEmitter();\n        /**\n         * Called when a draggable element is moved over the element\n         */\n        this.dragOver = new EventEmitter();\n        /**\n         * Called when a draggable element is dropped on this element\n         */\n        this.drop = new EventEmitter(); // eslint-disable-line  @angular-eslint/no-output-native\n    }\n    ngOnInit() {\n        this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe((drag$) => {\n            addClass(this.renderer, this.element, this.dragActiveClass);\n            const droppableElement = {\n                updateCache: true,\n            };\n            const deregisterScrollListener = this.renderer.listen(this.scrollContainer\n                ? this.scrollContainer.elementRef.nativeElement\n                : 'window', 'scroll', () => {\n                droppableElement.updateCache = true;\n            });\n            let currentDragEvent;\n            const overlaps$ = drag$.pipe(map(({ clientX, clientY, dropData, target }) => {\n                currentDragEvent = { clientX, clientY, dropData, target };\n                if (droppableElement.updateCache) {\n                    droppableElement.rect =\n                        this.element.nativeElement.getBoundingClientRect();\n                    if (this.scrollContainer) {\n                        droppableElement.scrollContainerRect =\n                            this.scrollContainer.elementRef.nativeElement.getBoundingClientRect();\n                    }\n                    droppableElement.updateCache = false;\n                }\n                const isWithinElement = isCoordinateWithinRectangle(clientX, clientY, droppableElement.rect);\n                const isDropAllowed = !this.validateDrop ||\n                    this.validateDrop({ clientX, clientY, target, dropData });\n                if (droppableElement.scrollContainerRect) {\n                    return (isWithinElement &&\n                        isDropAllowed &&\n                        isCoordinateWithinRectangle(clientX, clientY, droppableElement.scrollContainerRect));\n                }\n                else {\n                    return isWithinElement && isDropAllowed;\n                }\n            }));\n            const overlapsChanged$ = overlaps$.pipe(distinctUntilChanged());\n            let dragOverActive; // TODO - see if there's a way of doing this via rxjs\n            overlapsChanged$\n                .pipe(filter((overlapsNow) => overlapsNow))\n                .subscribe(() => {\n                dragOverActive = true;\n                addClass(this.renderer, this.element, this.dragOverClass);\n                if (this.dragEnter.observers.length > 0) {\n                    this.zone.run(() => {\n                        this.dragEnter.next(currentDragEvent);\n                    });\n                }\n            });\n            overlaps$.pipe(filter((overlapsNow) => overlapsNow)).subscribe(() => {\n                if (this.dragOver.observers.length > 0) {\n                    this.zone.run(() => {\n                        this.dragOver.next(currentDragEvent);\n                    });\n                }\n            });\n            overlapsChanged$\n                .pipe(pairwise(), filter(([didOverlap, overlapsNow]) => didOverlap && !overlapsNow))\n                .subscribe(() => {\n                dragOverActive = false;\n                removeClass(this.renderer, this.element, this.dragOverClass);\n                if (this.dragLeave.observers.length > 0) {\n                    this.zone.run(() => {\n                        this.dragLeave.next(currentDragEvent);\n                    });\n                }\n            });\n            drag$.subscribe({\n                complete: () => {\n                    deregisterScrollListener();\n                    removeClass(this.renderer, this.element, this.dragActiveClass);\n                    if (dragOverActive) {\n                        removeClass(this.renderer, this.element, this.dragOverClass);\n                        if (this.drop.observers.length > 0) {\n                            this.zone.run(() => {\n                                this.drop.next(currentDragEvent);\n                            });\n                        }\n                    }\n                },\n            });\n        });\n    }\n    ngOnDestroy() {\n        if (this.currentDragSubscription) {\n            this.currentDragSubscription.unsubscribe();\n        }\n    }\n}\nDroppableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: DroppableDirective, deps: [{ token: i0.ElementRef }, { token: DraggableHelper }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: DraggableScrollContainerDirective, optional: true }], target: i0.ɵɵFactoryTarget.Directive });\nDroppableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"12.2.3\", type: DroppableDirective, selector: \"[mwlDroppable]\", inputs: { dragOverClass: \"dragOverClass\", dragActiveClass: \"dragActiveClass\", validateDrop: \"validateDrop\" }, outputs: { dragEnter: \"dragEnter\", dragLeave: \"dragLeave\", dragOver: \"dragOver\", drop: \"drop\" }, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: DroppableDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[mwlDroppable]',\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: DraggableHelper }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: DraggableScrollContainerDirective, decorators: [{\n                    type: Optional\n                }] }]; }, propDecorators: { dragOverClass: [{\n                type: Input\n            }], dragActiveClass: [{\n                type: Input\n            }], validateDrop: [{\n                type: Input\n            }], dragEnter: [{\n                type: Output\n            }], dragLeave: [{\n                type: Output\n            }], dragOver: [{\n                type: Output\n            }], drop: [{\n                type: Output\n            }] } });\n\nclass DragAndDropModule {\n}\nDragAndDropModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: DragAndDropModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nDragAndDropModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: DragAndDropModule, declarations: [DraggableDirective,\n        DroppableDirective,\n        DraggableScrollContainerDirective], exports: [DraggableDirective,\n        DroppableDirective,\n        DraggableScrollContainerDirective] });\nDragAndDropModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: DragAndDropModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: DragAndDropModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [\n                        DraggableDirective,\n                        DroppableDirective,\n                        DraggableScrollContainerDirective,\n                    ],\n                    exports: [\n                        DraggableDirective,\n                        DroppableDirective,\n                        DraggableScrollContainerDirective,\n                    ],\n                }]\n        }] });\n\n/*\n * Public API Surface of angular-draggable-droppable\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DragAndDropModule, DraggableDirective, DraggableScrollContainerDirective, DroppableDirective };\n"]},"metadata":{},"sourceType":"module"}